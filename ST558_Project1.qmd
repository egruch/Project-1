---
title: "ST558 Project 1"
format: html
editor: visual
---

# Load Libraries

```{r}
# Load in the tidyverse libraries
library(tidyverse)
library(lubridate)
```

# Introduction

Introduction about what we are doing, discussion of what you are about to do and why/how, etc.

## Data

Maybe write anything about the API and data itself.

# Data Processing

## Helper Function

Getting the usual process to work with a given URL

Next, write a helper function to take what is returned by GET() and turn it into a nice tibble.

```{r}
APIurl <- "https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24&for=state:09&key=51fa8d7040e7bff1dae932352f6b998a4678a557"

# Helper function to take what is returned by GET() and turn it into a tibble
api_tibble <- function(GET_output) {
  census_parsed <- jsonlite::fromJSON(rawToChar(GET_output$content))
  
  colnames(census_parsed) <- census_parsed[1,]
  census_parsed <- census_parsed[-1,]
  census_tibble <- as_tibble(census_parsed)
  class(census_tibble) <- c("census", class(census_tibble))
  return(census_tibble)
}

api_tibble(httr::GET(APIurl))

# This gives character type data for all columns, may need to change.
```

## Single Year Function

Write a function to query the API that allows the user to change the following items: (see project outline).

if else logic test

```{r}
year = 2022
num_var <- "PWGTP,MAR"
num_var2 <- c("PWGTP", "MAR")
char_var = "SEX"
if (!is.numeric(year) | year < 2010 | year > 2022) {
  "BAD1" 
} else if (!is.element("PWGTP", num_var2)) {
    "BAD2"
} else if (length(num_var2) < 2) {
  "BAD3"
  } else if (char_var != "FER" & char_var != "HHL" & char_var != "HISPEED" &
             char_var != "JWTRNS" & char_var != "SCH" & char_var != "SCHL" &
             char_var != "SEX") {
    "BAD3"
  } else {
  "yay"
}

```

Dictionary
```{r}

```


```{r}
call_API <- function(year=2022, num_vars = c("PWGTP", "AGEP"), char_var = "SEX", geo_level = "state", geo_subset = "09") {
  if (!is.numeric(year) | year < 2010 | year > 2022) {
  
    stop("year input invalid!") 
    
  } else if (!is.element("PWGTP", num_vars)) {
  
    stop("numeric variables does not contain PWGTP") 
    
  } else if (length(num_vars) < 2) {
    
    stop("must enter more than one numeric variable")
    
  } else if (char_var != "FER" & char_var != "HHL" & char_var != "HISPEED" &
             char_var != "JWTRNS" & char_var != "SCH" & char_var != "SCHL" &
             char_var != "SEX") {
    
    stop("entered more than one variable or an invaild varaible") 
    
  } else {
    my_url <- paste0("https://api.census.gov/data/",
                     year,
                     "/acs/acs1/pums?get=",
                     char_var,
                     ",",
                     paste(num_vars,collapse =","),
                     "&for=",geolevel,":",
                     geo_subset,
                     "&key=51fa8d7040e7bff1dae932352f6b998a4678a557")
  }

 API_data <- api_tibble(my_url)
 
  #change to new data type
if ("SEX" %in% names(API_data)) {
  API_data <- API_data |>
    mutate(SEX = ifelse(SEX == "1", "Male", 
                         "Female")) |>
    mutate(SEX = factor(SEX))
} else if ("FER" %in% names(API_data)) {
  API_data <- API_tibble |>
    mutate(FER = ifelse(FER == "0", 
                        "N/A (less than 15 years/greater than 50 years/
                        male)", 
                        ifelse(FER == "2", "No", "Yes"))) |>
    mutate(FER = factor(FER))
}
}

API_data <- API_data |> 
   mutate(across(any_of(c("PWGTP", "AGEP", "GASP","GRPIP")), as.numeric))
```

```{r}
year <- 2022
num_var <- "PWGTP,AGEP,JWAP"
char_var <- "SEX,FER"
state <- "09"
my_url <- paste0("https://api.census.gov/data/",
                 year,
                 "/acs/acs1/pums?get=",
                 char_var,
                 ",",
                 num_var,
                 "&for=state:",
                 state,
                 "&key=51fa8d7040e7bff1dae932352f6b998a4678a557")
my_url

```

```{r}
# Somewhere we need to turn numerical variables into numeric or time values 
# Somwhere we need to turn categorical variables into factors 
# temporarily doing that here. 
census_data <- api_tibble(httr::GET(my_url))

if ("SEX" %in% names(census_data)) {
  census_data <- census_data |>
    mutate(SEX = ifelse(SEX == "1", "Male", 
                        ifelse(SEX == "2", "Female", "NA"))) |>
    mutate(SEX = factor(SEX))
}
 census_data |> 
   mutate(across(any_of(c("PWGTP", "AGEP", "GASP")), as.numeric))

census_data$SEX <- as.factor(census_data$SEX)
census_data$FER <- as.factor(census_data$FER)
census_data$PWGTP <- as.numeric(census_data$PWGTP)
census_data$AGEP <- as.numeric(census_data$AGEP)
census_data$GASP <- as.numeric(census_data$GASP)

census_data
```

## Multiple Year Function

Write a function that allows the user to specify multiple years of survey data (and all the other options above). Calls the single year function as many times as needed and then combines the data into one final tibble (with a year variable included).

## Summary Function

We can write our own custom summary function with the tibble that has a class of "census".

```{r}
# Write function that produces means and std devs for numeric variables
# and counts for categorical variables. 
summary.census <- function(data, 
                           num_var_vec = c("all"), 
                           cat_var_vec = c("all")) {
  summary_list <- list()
  # By default, summarize all numeric variables (other than PWGTP)
  # and all categorical variables in the tibble
  # User should be able to specify the variables they'd like to summarize
  if (num_var_vec[1] == "all") {
    # num_var_vec <- all is.numeric() columns in the tibble
  }
  if (cat_var_vec[1] == "all") {
    # cat_var_vec <- all is.character() columns in the tibble
  }
  
  for (var in num_var_vec) {
    if (var %in% names(data)) {
      # Calculate the sample mean for the numeric variable
      summary_list[paste0(var,"_mean")] <- 
        sum(data[,var] * data$PWGTP) / sum(data$PWGTP)
      
      # Calculate the sample standard deviation for the numeric variable
      sd_mean <- summary_list[[paste0(var,"_mean")]]
      summary_list[paste0(var, "_sd")] <- 
        sqrt(sum(data$PWGTP*(data[,var] - sd_mean)^2)/ (sum(data$PWGTP) - 1))
        
    }
  }
  
  # Counting the the categorical variables
  for (var in cat_var_vec) {
    summary_list[[paste0(var,"_count")]] <- data |> 
      group_by(data[,var]) |>
      summarise(count = sum(PWGTP))
  }
  
  # return the values as a named list
  return(summary_list)
}

summary(census_data, c("AGEP","GASP"), c("SEX","FER"))
```

## Plot Function

Code for creating a plot for a census class tibble with ggplot

Requires the user to specify one categorical variable and one numeric variable for plotting purposes.

```{r}
# Assumes that column names will be passed as strings. 
plot.census <- function(data, cat_var, num_var) {
  ggplot(data, 
         aes(x = get(cat_var), y = get(num_var), weight = PWGTP)) +
  geom_boxplot() +
    labs(title = paste(num_var, "Boxplots Grouped By", cat_var, sep=" "),
         x = cat_var, y = num_var)
}
```

```{r}
plot(census_data, "FER", "AGEP")
```
